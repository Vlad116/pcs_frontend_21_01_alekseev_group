'use strict';
{/*
	Различия non-strict и strict режимов

	1) Синтаксические ошибки:

	вызывают SyntaxError до выполнения скрипта:

	- Восьмеричное представление числа var n = 023;
	- Использование оператора with
	- Использование delete на имени переменной delete myVariable;
	- Использование eval или arguments как переменную или аргумент функции
	- Использование одного из новых зарезервированных ключевых слов (зарезервированных для ECMAScript 6): implements, interface, let, package, private, protected, public, static, и yield
	- Объявление функций в блоках if (a < b) { function f() {} }
	- Очевидные ошибки
	- Объявление дважды свойства с одним и тем же именем в литерале объекта {a: 1, b: 3, a: 7}. Это уже изменилось в ECMAScript 6 (баг 1041128).
	- Объявление нескольких аргументов функции с одним и тем же именем function f(a, b, b) {}

	Обличают скользкие, едва уловимые ошибки и плохие практики написания кода.

	2) Runtime errors:

	2.1) Установка значения необъявленной переменной:
		function f(x) {
			"use strict";
			var a = 12;
			b = a + x * 35; // error!
		}
		f(42);

		Здесь изменяется значение глобального объекта, что редко является ожидаемым эффектом. Если вы действительно хотите изменить значение глобального объекта, передайте его в качестве аргумента функции и явно присвойте его как свойство:

		var global = this; // в верхнем контексте "this" всегда
						// ссылается на глобальный объект
		function f(x) {
			"use strict";
			var a = 12;
			global.b = a + x * 35;
		}
		f(42);

	2.2) Попытка удалить неконфигурируемое свойство:

		"use strict";
		delete Object.prototype; // error!

		В нестрогом режиме этот код может молчаливо выполниться неудачей и ничего не сделать, вопреки ожиданиям.

	2.3) Отравленные аргументы (arguments) и свойства функции:

	Обращение к arguments.callee, arguments.caller, anyFunction.caller, или anyFunction.arguments выбросит исключение в строгом режиме. Единственный законный способ повторного использования функции как в:

	// Пример взят из vanillajs: http://vanilla-js.com/
	var s = document.getElementById('thing').style;
	s.opacity = 1;
	(function() {
	if((s.opacity-=.1) < 0)
		s.display = "none";
	else
		setTimeout(arguments.callee, 40);
	})();

	может быть переписан как:

	"use strict";
	var s = document.getElementById('thing').style;
	s.opacity = 1;
	(function fadeOut() { // имя функции
	if((s.opacity-=.1) < 0)
		s.display = "none";
	else
		setTimeout(fadeOut, 40); // используется имя функции
	})();

	3) Семантические различия:

	- this в вызовах функции
	- arguments не является псевдонимом именованных аргументов функции
	- Изменения в eval
*/}

console.log('Hello world from file!');

// ----------------------------------------------------------------

/* Переменные и константы. let, var, const. Типы данных. Область видимы
	Переменная – это «именованное хранилище» для данных. 
	Мы можем использовать переменные для хранения нужных нам данных.

	Два ограничения, касающиеся имён переменных:
	- Имя переменной должно содержать только буквы, цифры или символы $ и _.
	- Первый символ не должен быть цифрой.

	1. Инициализация и объявление переменной
	Объявление переменной - вводит новый идентификатор
	let result;
	Инициализация — это присваивание значения переменной.
*/
result = [0, 1234567890123456789012345678901234567890n, 0.23, 'Test', true, {}, Symbol('id'), null, undefined, console.log]
// В массиве проинициализированом выше представлены все возможные типы данных в js

for (let i = 0; i < result.length; i++) { // Выводит типы всех значений в массиве
	console.log(typeof result[i]);
}

// Infinity представляет собой математическую бесконечность ∞.
//  Это особое значение, которое больше любого числа.
console.log(1 / 0); // Infinity

// NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:
console.log("не число" / 2);

// Типы данных
// Число
let number = 9;

/* 
	BigInt - В JavaScript тип «number» не может содержать числа больше, чем (253-1) (т. е. 9007199254740991), 
	или меньше, чем -(253-1) для отрицательных чисел. Это техническое ограничение вызвано их внутренним представлением.
	Тип BigInt был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины.
	символ "n" в конце означает, что это BigInt 
*/

// Строка (string)
let string = "Привет";
let secondString = 'Одинарные кавычки "" тоже подойдут';
let phrase = `Обратные кавычки позволяют встраивать переменные: ${9 * 5}`;
console.log(phrase);

// Двойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript.
// Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в ${…}
// Булевый тип (boolean) может принимать только два значения: true (истина) и false (ложь).
let isChecked = false;

// Значение «null»
// Специальное значение null не относится ни к одному из типов, описанных выше.
// Оно формирует отдельный тип, который содержит только значение null:

let age = null;

/* 
	В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках.

	Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».

	Специальное значение undefined также стоит особняком. Оно формирует тип из самого себя так же, как и null.
 
	Оно означает, что «значение не было присвоено».
 
	Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined: 
*/

let surname;
console.log(surname);

/*
	Тип object (объект) 
	Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения (будь то строка, или число, или что-то ещё). 
	В объектах же хранят коллекции данных или более сложные структуры.
*/
const dataOgj = {
	name: 'Vlad',
	surname: surname,
	age: 22
}

// Тип symbol (символ) используется для создания уникальных идентификаторов в объектах.
// При создании символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:

// Создаём символ id с описанием (именем) "id"
let id = Symbol("id");

// Область видимости определяет, где в коде программы будут доступны переменные и функции
// JavaScript есть два типа области видимости — глобальная и локальная (global scope и function scope)


// Hoisting

// console.log(testVar)
// 
// // var
// if (isChecked === false){
// 	var testVar = 42;
// }
// let

// function getValue() {
// 	console.log(testLet);
// 	if(isChecked !== true){
// 		let testLet = 54;		
// 	}	
// }
// 
// getValue()

// const testConst;
const DEFAULT_ID = 26;
// DEFAULT_ID = 2;

// Преобразование типов

// Строковое преобразование
let value = true;
console.log(typeof value); // boolean

value = String(value); // теперь value это строка "true"
console.log(typeof value); // string

// Численное преобразование
console.log("3" * 3);

let str = "23";
console.log(typeof str); // string

let num = Number(str); // становится числом 123

console.log(typeof num); // number

// Явное преобразование часто применяется, когда мы ожидаем получить число из строкового контекста, например из текстовых полей форм.
// Если строка не может быть явно приведена к числу, то результатом преобразования будет NaN. Например:

age = Number("N");

console.log(age); 

// Логическое преобразование

// Правило преобразования:
// Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
// Все остальные значения становятся true.

console.log(Boolean(1)); // true
console.log(Boolean(0)); // false

console.log(Boolean("Привет!")); // true
console.log(Boolean("")); // false

let year = 2022

if (year < 2022) {
	console.log('Это слишком давно было...');
} else if (year > 2022) {
	console.log('Это поздновато, до него еще долго');
} else {
	console.log('Следующий год');
}

age = 30

let isAdult = age >= 18 ? true : false;
console.log(isAdult);

let username

console.log(username ?? 'Представьтесь пожалуйста!')

username = 'Vlad116'

console.log(username ?? 'Представьтесь пожалуйста!')


let i = 0;
while (i < 10) { // выводит 0, затем 1, затем 2
  console.log(i);
  i++;
}

let i = 3;
while (i) { // когда i будет равно 0, условие станет ложным, и цикл остановится
  console.log( i );
  i--;
}

let i = 4;
do {
	console.log(i);
	i--;
} while (i);

// function isNumber(a) {
// 	const castA = Number(a);
// 	return isNaN(castA) ? false : 
// 		typeof castA === 'number' ?
// 			true : false
// }
// 
// console.log(isNumber('3'));
// console.log(isNumber('r'));
// 
// function isLess(a, b) {
// 	if (isNumber(a) || isNumber(b)) {
// 		return a < b ? a : b;
// 	} else {
// 		return -1;
// 	}
// }
// 
// console.log(isLess('3','5'))
// console.log(isLess('trx','trd'))
// console.log(isLess('5', 'te'))